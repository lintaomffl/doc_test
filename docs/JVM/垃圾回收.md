# 垃圾回收

## 垃圾回收过程

1.判定不可达以后第一次标记；<br>
2.判断是否是否执行finalize方法:<br>	1)对象没覆盖finalize()；<br>	2)对象已经执行过finalize()——故该方法只执行1次<br>	3)对象需要执行finalize()，将对象放入F-Queue队列中<br>3. F-Queue中的对象，若在finalize方法中被再次引用起来，则离开该队列；<br>4.若没有，则进行二次标记，等待回收。



## 对象回收判断

### 引用标记法

引用标记法来判断是否进行对象回收；

### 可达性分析算法

从GC ROOT出发，去判断是否存在可达路径，如果不存在，则可以进行回收。

可作为GC ROOT的有：<br>1.虚拟机栈中引用的对象；<br>2.方法区中类静态属性引用的对象；<br>3.方法区中常量引用的对象；<br>4.本地方法栈中引用的对象；



## 垃圾回收算法

### 标记-清除

对于应该的回收对象进行标记，然后对于标记的对象进行清除。

**弊端**：会留下内存碎片；

**优势**：执行效率高。

<img src="https://img2018.cnblogs.com/blog/1055865/201811/1055865-20181115204746568-1515889800.jpg" alt="img" style="zoom:50%;" />

<img src="https://img2018.cnblogs.com/blog/1055865/201811/1055865-20181115204805970-502930121.jpg" alt="img" style="zoom:50%;" />



### 标记-整理

对于应该回收的对象进行标记，然后将保留下来的存活对象往一个方向移动。

**弊端**：执行效率较低；

**优势**：不会留下内存碎片，存活对象存储的空间连续。

<img src="https://img2018.cnblogs.com/blog/1055865/201811/1055865-20181115205130392-1110143654.jpg" alt="img" style="zoom:50%;" />

<img src="https://img2018.cnblogs.com/blog/1055865/201811/1055865-20181115205205753-794360164.jpg" alt="img" style="zoom:50%;" />

### 复制收集算法

将堆区域按照1:1进行划分，每次将存活的对象搬运到另一部分，然后将原来的那一半清除数据即可。

通常可以将堆区分为新生代与老年代，其中新生代以8:1:1的比例来划分“Eden”、“Survivor1”、“Survivor2”，领来，再分配出老年代区域。关于新的对象的内存分配可见下文。

**弊端**:空间利用率下降；

**好处**:不会有内存碎片。

<img src="https://img2018.cnblogs.com/blog/1055865/201811/1055865-20181115204836290-668818899.jpg" alt="img" style="zoom:50%;" />

<img src="https://img2018.cnblogs.com/blog/1055865/201811/1055865-20181115205057182-1900161260.jpg" alt="img" style="zoom:50%;" />



## 内存回收

### 内存回收器

### GC回收规模

**Minor GC**：主要针对**新生代**的垃圾回收动作，因为java对象大多存在朝生夕灭的情况，所以Minor GC通常频率高，且速度较快。

**Full GC/Major GC**：主要是针对**老年代**的垃圾回收，一次Major GC至少伴随一次Minor GC，且操作速度慢很多。



## 内存分配

新建对象的内存分配，通常是分配到堆区里。

1.新建对象，对象主要分配到新生代的Eden区；

2.如果开启了本地线程分配缓冲，则会将对象分配到TLAB(Thread Local Allocation Buffer)中;

3.少数情况直接分配到老年代。

### 优先分配新生代Eden

对于新建对象的堆存分配，大多情况下是分配到Eden里，如果该区域没有足够空间进行分配，则会发起一次Minor GC。进行Minor GC之后，幸存对象将会放入Survivor，并且将年龄＋1；

### 新生大对象进入老年代

对于占用空间较大大对象，则会将其分配进入老年代。可以利用-XX：PretenureSizeThreshold来设置分配入老年代的门限值。

### 长期存活则进入老年代

每次Minor GC 后，存活下来的对象将会被放入Survivor，并且年龄加1，当年龄达到-XX:MaxTenuringThreshols (默认值为5) 的值，则会放入老年代。

### 动态对象年龄判断

当新生代里同年龄的对象所占内存大于等于Survivor的一半的时候，那年龄大于等于这些对象的对象将会被放入老年代。

### 空间分配担保

Minor GC 将会导致一些对象年龄增加，然后被分配入老年代；

所以每次Minor GC之前，虚拟机会检查老年代的连续内存空间是否大于新生代的所有对象；

如果以上条件成立，则GC是安全的，所以可以执行；

如果不成立，则GC存在风险，那么会查看HandlePromotionFailure是否允许进行风险承担；

​	如果不允许承担风险，则进行Full GC;

​	如果允许承担风险，则计算之前新生代分配到老年代所占内存的平均值作为经验值，与老年代剩余空间比较；预估风险承担得起，则决定进行带风险地minor GC，还是预估风险无法承担，进行FullGC。

